import React from 'react';
import { FadeIn, FadeInStagger } from '@/components/animations/FadeIn';
import { HowToScroll } from '@/components/blocs/HowToScroll';
import { ChatGPTIcon } from '@/components/icons/ChatGPT';
import { GitHubCopilotIcon } from '@/components/icons/GitHubCopilot';
import { MongoDBIcon } from '@/components/icons/MongoDB';
import { PostgreIcon } from '@/components/icons/Postgre';
import { V0Icon } from '@/components/icons/V0';
import {
    Accordion,
    AccordionContent,
    AccordionItem,
    AccordionTrigger,
} from '@/components/ui/Accordion';
import { Separator } from '@/components/ui/Separator';
import { UsedLanguages } from '@/elements/stack/UsedLanguages';
import { ProjectStack } from '@/elements/stack/ProjectStack';
import { PreferredStack } from '@/elements/stack/Content';

export const metadata = {
    title: "Toutes les technologies que j'utilise quotidiennement",
    alternates: {
        canonical: '/stack',
    },
};

# Technologies que j'utilise

<FadeInStagger className="mt-10" faster>
    <FadeIn>
        Voici les *technologies* avec lesquelles je suis le plus **productif**, et avec lesquelles je **démarre** chaque projet, sans me poser des questions.
    </FadeIn>
    <FadeIn className="mt-6">
        <div className="scrollbar-hide flex h-14 w-full flex-row space-x-2 overflow-x-auto">
            {PreferredStack.map(({ icon, name }, index) => (
                <div key={index} className="flex aspect-square items-center justify-center rounded-md border border-neutral-200 bg-neutral-50 px-3 py-4 dark:border-neutral-700 dark:bg-neutral-800">
                    {icon}
                    <p className="sr-only">{name}</p>
                </div>
            ))}
        </div>
    </FadeIn>
    <FadeIn className="sm:hidden block mt-3">
        <HowToScroll>
            Vous pouvez scroller de <span className="font-medium text-theme">gauche</span> à <span className="font-medium text-theme">droite</span> pour voir toutes les technologies.
        </HowToScroll>
    </FadeIn>

    <Separator className="my-10" />

    <ProjectStack className="mt-6" />

    <Separator className="my-10" />

    <UsedLanguages className="mt-6" />

    <Separator className="my-10" />

    <FadeIn className="!text-2xl sm:!text-3xl" asChild>
        ## 1. Avec un framework plus orienté *front* (React et Next.js)
    </FadeIn>
    <FadeIn>
        <div className="mt-6">
            J'ai commencé à travailler avec *React* et *Next.js* en **2020**, à la fin de mes études.
            Depuis, j'ai eu l'occasion de développer plusieurs projets **professionnels**
            et **personnels** en utilisant ces technologies.
        </div>
        <div className="mt-3">
            Leur **flexibilité** et leur **puissance** m'ont permis de créer des
            applications web performantes et évolutives. Grâce à *Next.js*, j'ai pu tirer parti du rendu
            côté serveur *(SSR)* et de la génération de sites statiques *(SSG)*,
            ce qui a considérablement amélioré les **performances** et le **SEO** de mes projets.
        </div>
        <div className="mt-6">
            Quelques patterns super utiles et efficaces que j'utilise souvent avec **Next.js**,
            dans tous mes projets :
        </div>
        <Accordion className="mt-3" type="single" collapsible>
            <AccordionItem value="fetching-data">
                <AccordionTrigger className="text-neutral-600 dark:text-neutral-400">
                    <span className="text-theme font-extrabold">1.</span> Récupérer les données efficacement avec <span className="text-theme font-medium">Next.js</span>
                </AccordionTrigger>
                <AccordionContent>
                    J'évite d'utiliser des gestionnaires de route **API** pour
                    récupérer des données dans mes composants serveur.
                    <br/>À la place, je **récupère** les données directement dans mes composants
                    serveur. Cette approche tire parti des **optimisations** et du **caching** de *Next.js*.

                    ```tsx
                    const Home = async () => {
                        const res = await fetch('https://url.example.com/examples');
                        const data = await res.json();
                        return <div>{data.example}</div>;
                    }

                    export default Home;
                    ```

                    Pour une logique de récupération réutilisable, je crée des **actions serveur**
                    et je les importent là où c'est nécessaire.
                    Cette approche permet de réduire et de rendre le code plus lisible.

                    ```tsx
                    // actions/getExample.ts

                    'use server';

                    export const getExample = async () => {
                        const res = await fetch('https://url.example.com/examples');
                        const data = await res.json();
                        return data;
                    }

                    // Home.tsx
                    import { getExample } from '@/actions/getExample';

                    const Home = async () => {
                        const data = await getExample();
                        return <div>{data.example}</div>;
                    }

                    export default Home;
                    ```
                </AccordionContent>
            </AccordionItem>
            <AccordionItem value="components-client-server">
                <AccordionTrigger className="text-neutral-600 dark:text-neutral-400">
                    <span className="text-theme font-extrabold">2.</span> Utiliser les composants <span className="text-theme font-medium">client</span> et <span className="text-theme font-medium">serveur</span>
                </AccordionTrigger>
                <AccordionContent>
                    Comprendre la différence entre les composants **client** et **serveur** est crucial.
                    Par défaut, les pages sont des composants **serveur**, mais vous pouvez inclure
                    des composants **client** à l'intérieur pour l'**interactivité**.

                    ```tsx
                    // composant client

                    'use client';

                    import { useState } from 'react';

                    export const ClientComponent = () => {
                        const [count, setCount] = useState(0);

                        return (
                            <button onClick={() => setCount(count + 1)}>
                                Count: {count}
                            </button>
                        );
                    }

                    // composant serveur

                    import ClientComponent from '@/components/ClientComponent';

                    export const Home = () => (
                        <div>
                            <ClientComponent />
                        </div>
                    )
                    ```
                </AccordionContent>
            </AccordionItem>
            <AccordionItem value="static-generation">
                <AccordionTrigger className="text-neutral-600 dark:text-neutral-400">
                    <span className="text-theme font-extrabold">3.</span> Optimisation des images avec <span className="text-theme font-medium">next/image</span>
                </AccordionTrigger>
                <AccordionContent>
                    L'**optimisation des images** est toujours un élément clé
                    dans *Next.js*, et sur tous les sites web en général.
                    Avec <span className="text-theme font-medium">next/image</span>, vous pouvez
                    optimiser les images en utilisant des **formats optimisés**
                    et en générant des images différentes selon les différents appareils.

                    ```tsx
                    import Image from 'next/image';

                    export const ImageComponent = () => (
                    <Image
                        src="url-de-mon-image"
                        alt="description de l'image"
                        width={250}
                        height={250}
                        loading="lazy"
                    />
                    )
                    ```
                </AccordionContent>
            </AccordionItem>
        </Accordion>
    </FadeIn>

    <Separator className="my-10" />

    <FadeIn className="!text-2xl sm:!text-3xl" asChild>
        ## 2. Avec un framework plus orienté *back* (Express ou Fastify)
    </FadeIn>
    <FadeIn>
        <div className="mt-6">
            Pour les projets nécessitant un **backend** robuste, j'utilise des frameworks comme *Express* ou *Fastify*.
            *Express* est un choix populaire grâce à sa **simplicité** et sa **flexibilité**, tandis que *Fastify*
            se distingue par ses **performances élevées** et son **faible overhead**.
        </div>
        <div className="mt-3">
            Ces frameworks me permettent de créer des API rapides et scalables,
            tout en offrant une grande liberté dans la structuration du code et l'intégration de middlewares.
        </div>
        <Accordion className="mt-3" type="single" collapsible>
            <AccordionItem value="express">
                <AccordionTrigger className="text-neutral-600 dark:text-neutral-400">
                    <span className="text-theme font-extrabold">1.</span> Un petit exemple avec <span className="text-theme font-medium">Express</span>
                </AccordionTrigger>
                <AccordionContent>
                    Dans cet exemple, nous importons *express* et les types *Request* et *Response*.
                    Nous créons une application **Express**.
                    Nous définissons une *route GET* pour la racine (/) qui renvoie *"Hello, world!"*.
                    Nous démarrons le **serveur** sur le **port 3000** et affichons un message dans la **console**.

                    ```ts
                    import express, { Request, Response } from 'express';

                    const app = express();
                    const port = 3000;

                    app.get('/', (req: Request, res: Response) => {
                        res.send('Hello, world!');
                    });

                    app.listen(port, () => {
                        console.log(`Server is running at http://localhost:${port}`);
                    });
                    ```
                </AccordionContent>
            </AccordionItem>
            <AccordionItem value="fastify">
                <AccordionTrigger className="text-neutral-600 dark:text-neutral-400">
                    <span className="text-theme font-extrabold">2.</span> Un petit exemple avec <span className="text-theme font-medium">Fastify</span>
                </AccordionTrigger>
                <AccordionContent>
                    Dans cet exemple, nous importons **Fastify** et créons une instance de serveur.
                    Nous définissons une *route GET* pour la racine (/) qui renvoie un objet *JSON* avec le message *"Hello, world!"*.
                    Nous démarrons le serveur sur le **port 3000** et affichons un message dans la **console**.

                    ```ts
                    import Fastify from 'fastify';

                    const fastify = Fastify({ logger: true });

                    fastify.get('/', async (request, reply) => {
                        return { message: 'Hello, world!' };
                    });

                    const start = async () => {
                        try {
                            await fastify.listen({ port: 3000 });
                            console.log(`Server is running at http://localhost:3000`);
                        } catch (err) {
                            fastify.log.error(err);
                            process.exit(1);
                        }
                    };

                    start();
                    ```
                </AccordionContent>
            </AccordionItem>
        </Accordion>
    </FadeIn>

    <Separator className="my-10" />

    <FadeIn className="!text-2xl sm:!text-3xl" asChild>
        ## 3. Design et interfaces (*Tailwind CSS* et *shadcn/ui*)
    </FadeIn>
    <FadeIn>
        <div className="mt-6">
            Construire des composants **flexibles** et **accessibles** est un défi.
            On peut soit utiliser (et étendre) une **bibliothèque de composants**,
            soit créer ses **propres composants**.
            C’est pour cette raison que j’utilise désormais *shadcn/ui*.
        </div>
        <div className="mt-3">
            Cette bibliothèque propose des composants bien **conçus** et **extensibles**,
            basés sur des **primitives accessibles** et **non stylées**. Cela inclut des éléments de base comme
            des **boutons** et des **champs de saisie**, mais aussi des **icônes**, des **graphiques**,
            et même des **thèmes personnalisés**.
        </div>
        <div className="!text-lg sm:!text-xl mt-6">
            ### Pourquoi utiliser <span className="text-theme font-extrabold">Tailwind CSS</span> ?
        </div>
        <div className="mt-3">
            **Tailwind CSS** est un excellent outil pour accélérer la création de sites web
            grâce à ses classes prêtes à l’emploi, permettant d’éviter d’écrire du CSS
            personnalisé.
        </div>
        <div className="mt-3">
            On applique directement des classes aux éléments *HTML*, ce qui
            simplifie le design tout en assurant un *style cohérent* et un *code plus lisible*.
            Sa grande flexibilité permet de personnaliser facilement les styles via un
            fichier de configuration, d’ajuster les points de rupture pour le responsive et
            d’optimiser les performances en supprimant les classes inutilisées.
        </div>
        <div className="mt-3">
            De plus, avec une large communauté et des outils comme **Tailwind UI**, il est
            facile de profiter de ressources supplémentaires, ce qui fait de Tailwind un
            choix populaire pour des interfaces modernes et efficaces.
        </div>

        ```css
        @tailwind base;
        @tailwind components;
        @tailwind utilities;
        ```
    </FadeIn>

    <Separator className="my-10" />

    <FadeIn className="!text-2xl sm:!text-3xl" asChild>
        ## 4. Base de données (*MongoDB* ou *Postgres*)
    </FadeIn>
    <FadeIn>
        <div className="mt-6">
            Pour la gestion des **bases de données**, j'utilise principalement *MongoDB* et *Postgres*.
            *MongoDB* est une base de données **NoSQL** qui offre une grande flexibilité grâce à son
            **modèle de documents**, ce qui est idéal pour les applications nécessitant une **structure
            de données dynamique**.
        </div>
        <div className="mt-3">
            D'autre part, *Postgres* est une **base de données relationnelle** robuste
            et riche en fonctionnalités, parfaite pour les applications nécessitant des **transactions
            complexes** et une **intégrité des données** stricte. Ces deux bases de données me permettent
            de choisir la **solution la plus adaptée** en fonction des besoins spécifiques de chaque projet.
        </div>
        <div className="mt-6 scrollbar-hide flex h-14 w-full flex-row space-x-2 overflow-x-auto">
            <div className="flex aspect-square items-center justify-center rounded-md border border-neutral-200 bg-neutral-50 px-3 py-4 dark:border-neutral-700 dark:bg-neutral-800">
                <MongoDBIcon className="size-7 shrink-0" />
            </div>
            <div className="flex aspect-square items-center justify-center rounded-md border border-neutral-200 bg-neutral-50 px-3 py-4 dark:border-neutral-700 dark:bg-neutral-800">
                <PostgreIcon className="size-7 shrink-0" />
            </div>
        </div>
    </FadeIn>

    <Separator className="my-10" />

    <FadeIn className="!text-2xl sm:!text-3xl" asChild>
        ## 5. IA (*v0*, *GitHub Copilot* et *ChatGPT*)
    </FadeIn>
    <FadeIn>
        <div className="mt-6">
            Pour améliorer ma **productivité** et la **qualité** de mon code, j'utilise plusieurs outils
            d'**intelligence artificielle** comme *v0*, *GitHub Copilot* et *ChatGPT*.
        </div>
        <div className="mt-3">
            *v0* m'aide à **générer** des snippets de code en Front.
            *GitHub Copilot* fournit des **suggestions de code** en
            temps réel directement dans mon IDE, ce qui accélère le développement et réduit les erreurs.
        </div>
        <div className="mt-3">
            *ChatGPT* est utile pour obtenir des **explications détaillées**,
            des **exemples de code** et des **solutions à des problèmes complexes**.
        </div>
        <div className="mt-3">
            Ces outils ne sont pas parfaits, mais ils représentent un **gain de temps** considérable
            et **améliorent la qualité globale** de mes projets.
        </div>
        <div className="mt-6 scrollbar-hide flex h-14 w-full flex-row space-x-2 overflow-x-auto">
            <div className="flex aspect-square items-center justify-center rounded-md border border-neutral-200 bg-neutral-50 px-3 py-4 dark:border-neutral-700 dark:bg-neutral-800">
                <V0Icon className="size-7 shrink-0" />
            </div>
            <div className="flex aspect-square items-center justify-center rounded-md border border-neutral-200 bg-neutral-50 px-3 py-4 dark:border-neutral-700 dark:bg-neutral-800">
                <GitHubCopilotIcon className="size-7 shrink-0" />
            </div>
            <div className="flex aspect-square items-center justify-center rounded-md border border-neutral-200 bg-neutral-50 px-3 py-4 dark:border-neutral-700 dark:bg-neutral-800">
                <ChatGPTIcon className="size-7 shrink-0" />
            </div>
        </div>
    </FadeIn>
</FadeInStagger>
